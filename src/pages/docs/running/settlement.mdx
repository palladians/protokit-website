import { Callout } from "nextra/components";

# Settlement to the L1

Since applications built with protokit will in most cases operate as a zk-rollup, one integral part of that security model is the process of "settlement".

Settlement is the process of validating the integrity and correctness of the off-chain computation, proven to be valid via the so-called "Settlement Proof", by posting that proof on a underlying blockchain, often called the Layer-1 (L1) of baselayer.
In settlement, the entirety of the proofs generated by executing transactions on the protokit appchain are merged and bundled into one Mina transaction.
After that transaction is included in a Mina block and verified by the whole Mina network, all transactions that occured on the L2 can be considered valid and final.

Trustless bridging between the L1 and L2 is also possible through settlement. More on that in [Bridging](./bridging)

## Settlement in protokit

<Callout type="info">
    This API is not stable yet, so be sure to expect future changes
</Callout>

Protokit currently only offers one variant of settlement contracts.
They features set includes:
- Settlement (verification of protokit proofs on the Mina L1)
- Trustless MINA token deposits (L1 -> L2)
- Trustless MINA token withdrawals (L2 -> L1)

Customization capabilities of the settlement and bridging will follow in future releases.

The settlement functionality is implemented via a set of modules shipped with the protokit sequencer.
You can configure them by appending the configuration of your AppChain like:

```typescript showLineNumbers copy filename="packages/chain/src/chain.config.ts"
import { Balances } from "./guest-book/myBalance";
import { Withdrawals } from "@proto-kit/library";
import { SettlementContractModule } from "@proto-kit/protocol";
import { SettlementModule, MinaBaseLayer, WithdrawalQueue, SettlementProvingTask } from "@proto-kit/sequencer";

const appChain = LocalhostAppChain.with(
  {
    Balances,
    Withdrawals
  },
  {
    SettlementContractModule: SettlementContractModule.fromDefaults(),
  },
  {
    BaseLayer: MinaBaseLayer,
    SettlementModule: SettlementModule,
    OutgoingMessageQueue: WithdrawalQueue,
  },
  {
    SettlementProvingTask,
  }
);
```

One of the most important requirements is that a `Balances` runtime module has to exist in the configured runtime.
L1 Deposits and Withdrawals go through that module (see configuration below).

Additionally, the `Withdrawals` runtime module has to be set.
As with the default Balances module, it has no callable functions by default, therefore relies on user code to be called.

The responsibilities of the services configured above is the following:

| Service     | Responsibilities |
|:----------|:-----|
| **SettlementContractModule**     | Contains the provable L1 zkapp contracts that facilitate the settlement and trustless bridging  |
| **BaseLayer**     | Service to communcation with the Mina node endpoints (send transactions, query account states, ...)  |
| **OutgoingMessageQueue**  | Observes the protokit runtime and dispatches L1 transactions that process the withdrawals on Mina  |
| **SettlementModule**  | Uses all of the above to coordinate the settlement process and ensure the correct proof orchestration  |

### Configuring the settlement

```typescript showLineNumbers {9-12,16-17,26-27,31} copy filename="packages/chain/src/chain.config.ts"
appChain.configurePartial({
  Runtime: {
    Balances: {},
    Withdrawals: {},
  },
  Protocol: {
    SettlementContractModule: {
      SettlementContract: {
        // Path to the withdrawals StateMap as "moduleName.propertyName"
        withdrawalStatePath: "Withdrawals.withdrawals",
        // Path to the withdrawal @runtimeMethod() as "moduleName.methodName"
        withdrawalMethodPath: "Withdrawals.withdraw",
      },
      DispatchContract: {
        incomingMessagesMethods: {
          // Path to deposit @runtimeMessage() as "moduleName.methodName"
          deposit: "Balances.deposit",
        },
      },
    },
  },
  Sequencer: {
    OutgoingMessageQueue: {},
    BaseLayer: {
      network: {
        // Currently only local blockchain is supported
        local: true,
      },
    },
    SettlementModule: {
      feepayer: sequencerKey,
    },
  }
})
```

This configuration tells the protokit sequencer that methods are used for deposit and withdrawal calls and what `StateMap` outgoing withdrawals are put into.

Note:
- `withdrawalMethodPath`: Has to be a user-invokable runtime method (i.e. `@runtimeMethod()`) that under the hood calls the `Withdrawal.withdraw()` function provided by the Withdrawal module.
- `incomingMessagesMethods.deposit`: Has to be a runtime method annotated with `@runtimeMessage()`. This allows it to be invoked through the L1 contract's dispatched deposit.
