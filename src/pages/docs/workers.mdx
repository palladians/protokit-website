# Worker Architecture

All sequencer modules are registered, resolved and then started when the AppChain is started. Several of these modules
are what define the process to be a worker. This can be considered a lightweight instance of the AppChain that is responsible
for executing expensive asynchronous `tasks`, such as Block Proving, so that the main AppChain isn't blocked by them. For testing purposes,
it is fine to have the main AppChain be the worker, but in production set-ups you will likely want multiple workers defined,
separately.

## LocalTaskWorkerModule

This module is used to create a worker locally. Without this being defined in some process no worker will be spawned and
this means no tasks will be processed. This module is itself defined with several tasks that it will be capable of executing, such as
 - StateTransitionTask,
 - StateTransitionReductionTask,
 - RuntimeProvingTask,
 - BlockProvingTask,
 - BlockReductionTask,
 - BlockBuildingTak,
 - NewBlockTask,
 - CircuitCompilerTask
 - WorkerRegistrationTask.

When the `LocalTaskWorkerModule` is started it has a set of start-up tasks, like those above, passed to it. These tasks basically
define what sort of computations the worker can handle, as you may want different workers to handle different tasks for resourcing reasons.
There are two types of tasks: `Unprepared`, i.e. tasks that don’t have a prepare method and therefore don’t need to wait for registration to get initialized, and
 `Regular`, i.e. all other tasks that require registration.

When the worker is started it first registers the required callback functions for the `Unprepared` tasks, i.e. `CircuitCompilerTask` and `WorkerRegistrationTask`,
with the queue, so that when the queue receives these tasks the worker can process them. Then, the LocalWorkerTaskModule
calls the `prepare` method for non-startup/normal tasks, before registering them with the queue. This registration ensures the worker is ready to handle any request
when one later comes in. Once these are completed a promise is resolved, called `prepareResolve`. This tells the LocalWorkerTaskModule
it is ready, and the `LocalTaskWorkerModule` emits a `ready` event of its own that other modules like the `WorkerReadyModule` are waiting for to proceed.

## WorkerReadyModule

This is another sequencer module that waits until key events have been emitted by the `LocalTaskWorkerModule` to signal that the worker
is ready and that the app chain can continue. The `WorkerReadyModule` is called by the `AppChain.ts` at the end of the `start()` method.
If the `waitForReady()` method on the `WorkerReadyModule` is never resolved then the AppChain will never finish its start-up. Note that the
`waitForReady()` is will always complete if the AppChain is not a worker, in particular if `LocalTaskWorkerModule` is not defined.

## SequencerStartUpModule

This is module is designed to ensure that all zk-circuits are compiled and their verification keys are accessible to the workers that
will need them. This spares workers from having to waste resources compiling the circuits themselves. This is achieved by having the AppChain
use the verification keys, and compilation artifacts, which are static parameters, as input to the `WorkerRegistrationFlow`. This in turns leaves
it as a task on the queue. A worker when starting-up will process the task that has been pushed onto the queue and access these static parameters
that way. In order for subsequent workers to have access to the same task, which will be removed from the queue after having been executed, the
sequencer uses the `WorkerRegistrationFlow` to push the same task again in a boundless loop. This loop consumes no resources as it is just a `Promise` that
awaits until a worker has registered. We ensure it's the new worker that picks up this task from the queue and not an older worker that is already configured,
by having the old worker be configured to delete the task-handler for the registration from its local queue so that it can't handle that particular kind of task, anymore.

## TaskQueue

The TaskQueue has two different implementations:

### BullQueue
This is Redis underneath. Each worker registers to consume specific jobs. Redis takes care of a lot of the implementation details.
This uses a separate Redis instance, whose configuration details are shared with the AppChain  on start-up.
In the starter-kit, this is run from Docker.

### LocalTaskQueue
This can only be used by one worker built into the AppChain, as it's not really a queue, executing tasks directly where possible.
The `workNextTasks()` is called whenever a task is added to the queue and again after tasks have already been executed (in case any others have been added in the meanwhile).
The `LocalTaskQueue` isn't suitable for production usage because it runs only one instance in-process. But for mock-proofs it's good enough.


